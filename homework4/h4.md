Homework #4 Loustau-Dondero
===========================

Problem 1
---------

Problem 2
---------
Acknowledgments:
regex101.com

a) Python

    import re
    p = re.compile(ur'^"[^\x00-\x0F\x80-\xA0]+"$', re.MULTILINE)
    test_str = u"g1\nb2\ncdadadedfaebadjaapjdinpanian!c\niadjioajaiojaaA\n80\nA0\ncadaladjal\nldjlajalc\ncaldjaldajlc\n\n\"ajdakljadlkjadlk\"jjlk\"\n\n[^\x00-\x0F\x80-\xA0]+"
    re.findall(p, test_str)

Javascript

    var re = /^"[^\x00-\x0F\x80-\xA0]+"$/gm; 
    var str = 'g1\nb2\ncdadadedfaebadjaapjdinpanian!c\niadjioajaiojaaA\n80\nA0\ncadaladjal\nldjlajalc\ncaldjaldajlc\'\nread\nred\nreal\n \n \n\n"ajdakljadlkjadlk\"jjlk"\n\n[^\x00-\x0F\x80-\xA0]+';
    str = str.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
    var m;
     
    while ((m = re.exec(str)) != null) {
        if (m.index === re.lastIndex) {
            re.lastIndex++;
        }
    }

b) Python

    import re
    p = re.compile(ur'^\*[^\*]*\*$')
    test_str = u"*ba*"
     
    re.search(p, test_str)

Javascript

    var re = /^\*[^\*]*\*$/; 
    var str = '*ba*';
    var m;
     
    while ((m = re.exec(str)) != null) {
        if (m.index === re.lastIndex) {
            re.lastIndex++;
        }
    }

c)
http://stackoverflow.com/questions/13340717/json-numbers-regular-expression

Python

    import re
    p = re.compile(ur'-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?', re.MULTILINE)
    test_str = u"g1\nb2\ncdadadedfaebadjaapjdinpanian!c\niadjioajaiojaaA\n80\nA0\ncadaladjal\nldjlajalc\ncaldjaldajlc'\nread\nred\nreal\n \n \n\n\"ajdakljadlkjadlk\"jjlk\"\n\n[^\x00-\x0F\x80-\xA0]+"
     
    re.findall(p, test_str)

Javascript

    var re = /-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?/gm; 
    var str = 'g1\nb2\ncdadadedfaebadjaapjdinpanian!c\niadjioajaiojaaA\n80\nA0\ncadaladjal\nldjlajalc\ncaldjaldajlc\'\nread\nred\nreal\n \n \n\n"ajdakljadlkjadlk\"jjlk"\n\n[^\x00-\x0F\x80-\xA0]+';
    var m;
     
    while ((m = re.exec(str)) != null) {
        if (m.index === re.lastIndex) {
            re.lastIndex++;
        }
    }

d)
Python

    import re
    p = re.compile(ur'^((?!read|red|real|\s).)+', re.MULTILINE)
    test_str = u"g1\nb2\ncdadadedfaebadjaapjdinpanian!c\niadjioajaiojaaA\n80\nA0\ncadaladjal\nldjlajalc\ncaldjaldajlc'\nread\nred\nreal\n \n \n\n\"ajdakljadlkjadlk\"jjlk\"\n\n[^\x00-\x0F\x80-\xA0]+"
     
    re.findall(p, test_str)

Javascript

    var re = /^((?!read|red|real|\s).)+/gm; 
    var str = 'g1\nb2\ncdadadedfaebadjaapjdinpanian!c\niadjioajaiojaaA\n80\nA0\ncadaladjal\nldjlajalc\ncaldjaldajlc\'\nread\nred\nreal\n \n \n\n"ajdakljadlkjadlk\"jjlk"\n\n[^\x00-\x0F\x80-\xA0]+';
    var m;
     
    while ((m = re.exec(str)) != null) {
        if (m.index === re.lastIndex) {
            re.lastIndex++;
        }
    }

3) 

4) 
double *a[n]; // array of n pointers to doubles
double (*b)[n]; // pointer to array of n doubles
double (*c[n])(); // array of n pointers to functions taking unspecified number of arguments returning doubles
double (*d())[n]; // function taking unspecified number of arguments and returning pointer to array of n doubles

Go
var a [n]*float64
var *b [n]float64
var c [n]*func ()float64{}
func d() *[n]float64 {
}

Rust
let a: [*mut f64, ..n];          
let b: *mut [f64, ..n];          
let c: [fn() -> f64, ..n];        
fn d() -> *mut [f64, ..n];


5) If I were a compiler, I would not be happy at all. In fact, I would be quite sad, upset and disappointed at the human being that wrote the code snippet aforementioned. Because of his mistake I would go into an infite loop and have to wait for an external event to terminate the loop. However, if I were smart enough and could recognize dependencies in the code I would just refuse to compile it, thus avoiding getting into the silly loop.  

6) 
7.4 The pass statement
https://docs.python.org/3/reference/simple_stmts.html

    def g(): print("left")
    def h(): print("right")
    def f(x, y): pass
    f(g(), h())

7)
In most language implementations, the activation records for different instances of foo will occupy the same space in the stack. Local variable i is never initialized (that's why the program is erroneous), but if the stack space has not been used for anything else in the meantime it may "inherit" a value from the previous instance of the routine. If the stack is created from space filled by zeros by the operating system, and if the space occupied by foo's activation record is not used for anything else before the first time foo is called, then i will start with the value zero in the first iteration of the loop.

8)
With dynamic scoping, the current binding for a name is the one most recently enocuntered during execution. 

If the program uses shallow binding, it will output 10203040. This is becaue the calls to setX and printX in foo, use the local x, which takes the values 1, 2, 3, and 4 successively and the calls to print_x from the body of the script use the global x which is always 0.

If the program, on the other hand, uses deep binding, it will output 10x20044. This is because the direct calls refer to the local x. The only relevant scenario when shallow and deep binind differ is when a subroutine is called through a reference. SetX and printX, in this program, refer to a variable x. When they are passed, x referred to the global x. In the case of deep binding, the parameters S and P will be such that they will refer to the global x.

9) Early versions of Fortran (such as Fortran IV) used call by reference, but also passed constants by reference,  allowing them (constants) to change their values.

In early versions of Fortran, when a variable is passed as a actual argument to  a procedure, and the procedure modifies the corresponding dummy argument, the variable itself gets modified. In other words, changing the value of a dummy argument inside  a procedure changes the actual/formal variable (corresponding entity used in the CALL statement) that invoked it. This is exactly what happened to the constant 2 in the code provided.

As pointed out by this example, the main disadvante of passign by reference is that one may accidentally change an argument one didn't mean to. If modification of constants is possible, it defeats the original purpose of a programming safety measure, and turns constants into a programming trap.

10) a) 1,2,3,4
    b) 2,2,2,4
    c) 2,2,3,4
    d) 2,2,3,3

  value — Argument value is copied to the parameter; changes to parameter are not reflected in argument.
  value/result — Argument value copied in; parameter value copied out at end of callee.
  reference — An implementation of aliasing through passing the address of the argument.
  name — Parameter is more or less a macro, taking on the source code text of the argument.