1)
2)
a)
    Python

    Javascript
    var re = /^"[^\x00-\x0F\x80-\xA0]+"$/gm; 
    var str = 'g1\nb2\ncdadadedfaebadjaapjdinpanian!c\niadjioajaiojaaA\n80\nA0\ncadaladjal\nldjlajalc\ncaldjaldajlc\n\n"ajdakljadlkjadlk\"jjlk"\n\n[^\x00-\x0F\x80-\xA0]+';
    var m;
 
while ((m = re.exec(str)) != null) {
    if (m.index === re.lastIndex) {
        re.lastIndex++;
    }
    // View your result using the m-variable.
    // eg m[0] etc.
}
b)

c)

3) 
A tail recursive function returns exactly the result of calling itself — no partial results need to be stored. A good compiler can recognize tail recursion and generate code that has no calls at all: just reload the parameters and jump back to the top

/* C */

int arrayMin(int* a, int n) {
// TODO
}


// JavaScript


var arrayMin = function (array) {
var helper = function (a, m) {
return a.length === 0 ? m : helper(a.slice(1), m < a[0] ? m : a[0])
}
return helper(array, Infinity);
}
;

Python

Go

4) 



5) If I were a compiler, I would not be happy at all. In fact, I would be quite sad, upset and disappointed at the human being that wrote the code snippet aforementioned. Because of his mistake I would go into an infite loop and have to wait for an external event to terminate the loop. However, if I were smart enough and could recognize dependencies in the code I would just refuse to compile it, thus avoiding getting into the silly loop.  

6) Python

def f(): print("left")
def g(): print("right")
def h(x, y): pass
h(f(), g())


7)
 The stack may have been cleared when the app started, and each time foo() is called the new activation
record ends up exactly where the old one was. On other systems the stack might not have been initialized, or
foo could have been inlined, so in general you cannot rely on anything specific being produced in this app.


8) With shallow binding, all calls to setX and printX within foo, regardless of whether they are called directly or
indirectly through parameters passed to foo, use the localized x, which is successively 1, 2, 3, and then 4. All
calls to print_x from the main part of the script use the global x which is always 0. The output is 10203040.
With deep binding, the direct calls refer to the localized x, because direct calls are simply regular old calls
and the basic dynamic scoping rules apply. The only time we ever care about deep and shallow binding is
when a subroutine is called through a reference. In this problem we are passing setX and printX, which refer
to a variable x. When we passed them, x referred to the global x. So with deep binding, the parameters S and
P will be such that they will refer to the global x. Tracing the execution:
Pass in main in foo in foo in main
-------------------------------------------------------
1 global:=0 local:=1 print local print global
2 global:=0 global:=2 print local print global
3 global:=0 local:=3 print global print global
4 global:=0 global:=4 print global print global
The output is 10x20044 where x represents implementation-specific garbage.


9) 	The compiler placed the value of the literal 2 in memory somewhere, and every time it saw a 2 in 	the source code it generated code to look in that memory address. The value in that memory cell got changed though.
Modern Fortran compilers still pass by reference, but they make a copy of any read-only argument (like a
literal) and pass references (pointers) to the copies.

10) a) 1,2,3,4
	b) 2,2,2,4
	c) 2,2,3,4
	d) 2,2,3,3

	value — Argument value is copied to the parameter; changes to parameter are not reflected in argument.
	value/result — Argument value copied in; parameter value copied out at end of callee.
	reference — An implementation of aliasing through passing the address of the argument.
	name — Parameter is more or less a macro, taking on the source code text of the argument.